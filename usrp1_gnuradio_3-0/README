BERT testing example scripts


benchmark_tx.py

This sets up a BPSK transmitter that is modulated with a pseudorandom
sequence of bits.  The PN code is generated by sending an all 1s
sequence through a 7-bit scrambler. The transmitter performs the BPSK
modulation, then passes the complex baseband waveform through a
root-raised-cosine filter and onto the USRP.

The --sps parameter controls how many baseband samples per symbol
are created and passed through the RRC filter, prior to going to the
USRP over the USB for interpolation to the final DAC rate.

The baseband bit rate is controlled by -r or --rate.  This value, when
multiplied by the --sps parameter, must result in valid interpolation
rate for the USRP.  For example, if the baseband rate is 250k bits/sec,
and the samples per symbol is 4, then the final rate is 1M samples/sec,
which results in an interpolation rate of 128.  The valid interpolation
rates for the USRP are multiples of 4 between 16 and 512.

Finally, the RRC excess bandwidth may be specified by --excess-bw.
(See ./benchmark_tx.py -h for additional parameters.)


benchmark_rx.py

This sets up a BPSK receiver to demodulate the received waveform.  It
accepts a similar set of parameters as the transmitter, except that one
specifies the USRP decimation rate desired.  The resulting sample stream
rate must be an integral number of baseband symbols.  For example, the
parameters corresponding to the above transmitter would be to use a
decimation rate of 8 (32 sps), 16 (16 sps), 32 (8 sps), 64, (4 sps), or
128 (2 sps).  The lower the USRP decimation, the more CPU is required to
demodulate the signal, so not all valid decimation rates will work.

The baseband signal from the USRP is first passed through an AGC to
establish an average power of 1.0.  It is then passed through a matched
filter (another RRC), a Costas phase-locked loop, and a Mueller and
Muller bit timing recovery loop.  The resulting constellation has an SNR
estimation probe attached, and is then sliced into a bit stream.

The recovered bits are then passed through a 7-bit descrambler.  If
there are no channel errors, the all 1s sequence is recovered. In the 
event of a channel error, there will be a 0 in the bit stream for each
feedback tap in the descrambler.  In this case, the CCSDS descrambler is
using 3 feedback taps.

Finally, the signal is passed into a bit density measurement probe. The
channel BER is measured by dividing the 0s density by three.  This
measurement is inaccurate at high BER rates (>10%) as the error 0s
begin to overlap.

The benchmark script will, once per second, output the Costas loop
frequency offset, the recovered timing error, the estimated SNR, and the
average BER.

NOTE: The particular SNR estimator used is inaccurate below about 7dB,
and will report erroneously high values even for random noise.

There are a variety of Costas and M&M loop parameters one can adjust.
See ./benchmark_rx.py -h for the full set.
